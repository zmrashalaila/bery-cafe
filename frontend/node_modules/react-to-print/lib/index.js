!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("react")):"function"==typeof define&&define.amd?define("lib",["react"],t):"object"==typeof exports?exports.lib=t(require("react")):e.lib=t(e.react)}("undefined"!=typeof self?self:this,(function(e){return function(){"use strict";var t={155:function(t){t.exports=e}},o={};function n(e){var r=o[e];if(void 0!==r)return r.exports;var s=o[e]={exports:{}};return t[e](s,s.exports,n),s.exports}n.d=function(e,t){for(var o in t)n.o(t,o)&&!n.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};n.r(r),n.d(r,{useReactToPrint:function(){return f}});var s=n(155);function i({level:e="error",messages:t,suppressErrors:o=!1}){o||("error"===e?console.error(t):"warning"===e?console.warn(t):"debug"===e&&console.debug(t))}function l(e,t){if(t||!e){const e=document.getElementById("printWindow");e&&document.body.removeChild(e)}}function a(e,t){const{documentTitle:o,onAfterPrint:n,onPrintError:r,preserveAfterPrint:s,print:a,suppressErrors:c}=t;setTimeout((()=>{var t,d;if(e.contentWindow)if(e.contentWindow.focus(),a)a(e).then((()=>null==n?void 0:n())).then((()=>l(s))).catch((e=>{r?r("print",e):i({messages:["An error was thrown by the specified `print` function"],suppressErrors:c})}));else{if(e.contentWindow.print){const n=null!==(d=null===(t=e.contentDocument)||void 0===t?void 0:t.title)&&void 0!==d?d:"",r=e.ownerDocument.title;o&&(e.ownerDocument.title=o,e.contentDocument&&(e.contentDocument.title=o)),e.contentWindow.print(),o&&(e.ownerDocument.title=r,e.contentDocument&&(e.contentDocument.title=n))}else i({messages:["Printing for this browser is not currently possible: the browser does not have a `print` method available for iframes."],suppressErrors:c});null==n||n(),l(s)}else i({messages:["Printing failed because the `contentWindow` of the print iframe did not load. This is possibly an error with `react-to-print`. Please file an issue: https://github.com/MatthewHerbst/react-to-print/issues/"],suppressErrors:c})}),500)}function c(e){const t=[],o=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null);let n=o.nextNode();for(;n;)t.push(n),n=o.nextNode();return t}function d(e,t,o){const n=c(e),r=c(t);if(n.length===r.length)for(let e=0;e<n.length;e++){const t=n[e],s=r[e],i=t.shadowRoot;if(null!==i){const e=s.attachShadow({mode:i.mode});e.innerHTML=i.innerHTML,d(i,e,o)}}else i({messages:["When cloning shadow root content, source and target elements have different size. `onBeforePrint` likely resolved too early.",e,t],suppressErrors:o})}const u='\n    @page {\n        /* Remove browser default header (title) and footer (url) */\n        margin: 0;\n    }\n    @media print {\n        body {\n            /* Tell browsers to print background colors */\n            color-adjust: exact; /* Firefox. This is an older version of "print-color-adjust" */\n            print-color-adjust: exact; /* Firefox/Safari */\n            -webkit-print-color-adjust: exact; /* Chrome/Safari/Edge/Opera */\n        }\n    }\n';function p(e,t,o,n){var r,s,l;const{contentNode:c,clonedContentNode:p,clonedImgNodes:h,clonedVideoNodes:f,numResourcesToLoad:g,originalCanvasNodes:m}=o,{bodyClass:b,fonts:y,ignoreGlobalStyles:v,pageStyle:w,nonce:E,suppressErrors:T,copyShadowRoots:A}=n;e.onload=null;const x=e.contentDocument||(null===(r=e.contentWindow)||void 0===r?void 0:r.document);if(x){const o=x.body.appendChild(p);A&&d(c,o,!!T),y&&((null===(s=e.contentDocument)||void 0===s?void 0:s.fonts)&&(null===(l=e.contentWindow)||void 0===l?void 0:l.FontFace)?y.forEach((o=>{const n=new FontFace(o.family,o.source,{weight:o.weight,style:o.style});e.contentDocument.fonts.add(n),n.loaded.then((()=>{t(n)})).catch((e=>{t(n,["Failed loading the font:",n,"Load error:",e])}))})):(y.forEach((e=>t(e))),i({messages:['"react-to-print" is not able to load custom fonts because the browser does not support the FontFace API but will continue attempting to print the page'],suppressErrors:T})));const n=null!=w?w:u,r=x.createElement("style");E&&(r.setAttribute("nonce",E),x.head.setAttribute("nonce",E)),r.appendChild(x.createTextNode(n)),x.head.appendChild(r),b&&x.body.classList.add(...b.split(" "));const a=x.querySelectorAll("canvas");for(let e=0;e<m.length;++e){const t=m[e],o=a[e];if(void 0===o){i({messages:["A canvas element could not be copied for printing, has it loaded? `onBeforePrint` likely resolved too early.",t],suppressErrors:T});continue}const n=o.getContext("2d");n&&n.drawImage(t,0,0)}for(let e=0;e<h.length;e++){const o=h[e],n=o.getAttribute("src");if(n){const e=new Image;e.onload=()=>t(o),e.onerror=(e,n,r,s,i)=>t(o,["Error loading <img>",o,"Error",i]),e.src=n}else t(o,['Found an <img> tag with an empty "src" attribute. This prevents pre-loading it.',o])}for(let e=0;e<f.length;e++){const o=f[e];o.preload="auto";const n=o.getAttribute("poster");if(n){const e=new Image;e.onload=()=>t(o),e.onerror=(e,r,s,i,l)=>t(o,["Error loading video poster",n,"for video",o,"Error:",l]),e.src=n}else o.readyState>=2?t(o):(o.onloadeddata=()=>t(o),o.onerror=(e,n,r,s,i)=>t(o,["Error loading video",o,"Error",i]),o.onstalled=()=>t(o,["Loading video stalled, skipping",o]))}if(!v){const e=document.querySelectorAll("style, link[rel~='stylesheet'], link[as='style']");for(let o=0,n=e.length;o<n;++o){const n=e[o];if("style"===n.tagName.toLowerCase()){const e=x.createElement(n.tagName),t=n.sheet;if(t){let r="";try{const e=t.cssRules.length;for(let o=0;o<e;++o)"string"==typeof t.cssRules[o].cssText&&(r+=`${t.cssRules[o].cssText}\r\n`)}catch(e){i({messages:["A stylesheet could not be accessed. This is likely due to the stylesheet having cross-origin imports, and many browsers block script access to cross-origin stylesheets. See https://github.com/MatthewHerbst/react-to-print/issues/429 for details. You may be able to load the sheet by both marking the stylesheet with the cross `crossorigin` attribute, and setting the `Access-Control-Allow-Origin` header on the server serving the stylesheet. Alternatively, host the stylesheet on your domain to avoid this issue entirely.",n,`Original error: ${null==e?void 0:e.message}`],level:"warning"})}e.setAttribute("id",`react-to-print-${o}`),E&&e.setAttribute("nonce",E),e.appendChild(x.createTextNode(r)),x.head.appendChild(e)}}else if(n.getAttribute("href"))if(n.hasAttribute("disabled"))i({messages:["`react-to-print` encountered a <link> tag with a `disabled` attribute and will ignore it. Note that the `disabled` attribute is deprecated, and some browsers ignore it. You should stop using it. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-disabled. The <link> is:",n],level:"warning"}),t(n);else{const e=x.createElement(n.tagName);for(let t=0,o=n.attributes.length;t<o;++t){const o=n.attributes[t];o&&e.setAttribute(o.nodeName,o.nodeValue||"")}e.onload=()=>t(e),e.onerror=(o,n,r,s,i)=>t(e,["Failed to load",e,"Error:",i]),E&&e.setAttribute("nonce",E),x.head.appendChild(e)}else i({messages:["`react-to-print` encountered a <link> tag with an empty `href` attribute. In addition to being invalid HTML, this can cause problems in many browsers, and so the <link> was not loaded. The <link> is:",n],level:"warning"}),t(n)}}}0===g&&a(e,n)}function h(e,t,o,n){e.onload=()=>p(e,t,o,n),document.body.appendChild(e)}function f(e){const{contentRef:t,fonts:o,ignoreGlobalStyles:n,onBeforePrint:r,onPrintError:c,preserveAfterPrint:d,suppressErrors:u}=e,p=(0,s.useCallback)((s=>{l(d,!0);const p=function({contentRef:e,optionalContent:t,suppressErrors:o}){return t&&(e&&i({level:"warning",messages:['"react-to-print" received a `contentRef` option and a optional-content param passed to its callback. The `contentRef` option will be ignored.']}),"function"==typeof t)?t():e?e.current:void i({messages:['"react-to-print" did not receive a `contentRef` option or a optional-content param pass to its callback.'],suppressErrors:o})}({contentRef:t,optionalContent:s,suppressErrors:u});if(!p)return void i({messages:["There is nothing to print"],suppressErrors:u});const f=p.cloneNode(!0),g=document.querySelectorAll("link[rel~='stylesheet'], link[as='style']"),m=f.querySelectorAll("img"),b=f.querySelectorAll("video"),y=o?o.length:0,v=(n?0:g.length)+m.length+b.length+y,w=[],E=[],T=function(){const e=document.createElement("iframe");return e.width=`${document.documentElement.clientWidth}px`,e.height=`${document.documentElement.clientHeight}px`,e.style.position="absolute",e.style.top=`-${document.documentElement.clientHeight+100}px`,e.style.left=`-${document.documentElement.clientWidth+100}px`,e.id="printWindow",e.srcdoc="<!DOCTYPE html>",e}(),A=(t,o)=>{w.includes(t)?i({level:"debug",messages:["Tried to mark a resource that has already been handled",t],suppressErrors:u}):(o?(i({messages:['"react-to-print" was unable to load a resource but will continue attempting to print the page',...o],suppressErrors:u}),E.push(t)):w.push(t),w.length+E.length===v&&a(T,e))},x={contentNode:p,clonedContentNode:f,clonedImgNodes:m,clonedVideoNodes:b,numResourcesToLoad:v,originalCanvasNodes:p.querySelectorAll("canvas")};r?r().then((()=>h(T,A,x,e))).catch((e=>{null==c||c("onBeforePrint",e)})):h(T,A,x,e)}),[e]);return p}return r}()}));